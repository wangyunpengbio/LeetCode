class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m=len(s)
        n=len(p)
        dp = [[bool(0) for i in range(n+1)] for j in range(m+1)]
        dp[0][0] = bool(1)
        # 开始初始化填充,如果匹配的串s是空的的话，只有模式是"x*x*"这样一个字符一个*排列的，才能匹配
        for j in range(1,n+1):
            if p[j-1] == '*':
                dp[0][j] = dp[0][j-2]
            else:
                dp[0][j] = bool(0)
        ## 开始动态规划
        for i in range(1,m+1): # 待匹配的字符串 s
            for j in range(1,n+1): # 模式 p
                # 这里i j 可以有两种情况转化而来。
                # 第一种情况：s去掉*和*之前字母能够 匹配。也就是*之前字母取0次。
                # 第二种情况：a.  *和*之前字母取一次,匹配s中第i个字母，（用递归 所以从1次开始往后几次也是都可以）
                # 第二种情况：b.  这种情况是& 也就是 一定要匹配s中第i-1 。也是因为*之前字母可以取0次，换句话说如果不能匹配i-1 那么一定不能匹配[i][j]
                # 情况二就是"$$$$a*"
                #          "$$$$aa"
                # 第一波算出"$$$$a*" 与 "$$$$" 可以匹配
                # 第二波算出"$$$$a*" 与 "$$$$a" 可以匹配
                # 第三波算出"$$$$a*" 与 "$$$$aa" 可以匹配 所以第二种情况要保证用and连接上dp[i-1][j]
                if p[j-1] == '*':
                    dp[i][j] = dp[i][j-2] or (s[i-1]==p[j-2] or p[j-2]=='.') and dp[i-1][j]
                else:
                # 把. 当成普通字符一起匹配。这个就比较简单当前位置一样，或者是. 并且[i-1][j-1]也是要匹配
                    dp[i][j] = (s[i-1]==p[j-1] or p[j-1]=='.') and dp[i-1][j-1]
        return dp[m][n]

