class Solution:
    # 5 --- 0000 0101
    # 6 --- 0000 0110
    # 7 --- 0000 0111
    # _______________
    # 4 --- 0000 0100
    # https://blog.csdn.net/smile_watermelon/article/details/47320381
# 010111 + 1 = 011000，则010111 & 011000 = 010000。那么，x & (x+1) 后几位相反数的“与操作”，结果总为0。
# 所以，当(m,m+1,...n-1,n)进行连续“与操作”时，会按照上述规律被抵消很大一部分，而只剩下n的前缀部分，最后只需将n归位。举个例子：

# m = 5(0101), n = 7 (0111)。不停右移，得到n前缀部分为01，最后归位前缀得res=0100=4
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        # 具体代码实现中，我们只需要比较m和n的前缀。因为如果m和n二进制位数不同，[m...n] 按位与的结果一定是0.
        offset = 0
        while m != n:
            m >>= 1
            n >>= 1
            offset += 1
        return n << offset